import AppDevUtils
import ComposableArchitecture
import SwiftUI

@MainActor
struct ImproveTranscriptionButton: View {
  struct TextCompletion: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage

    struct Choice: Codable {
      let text: String
      let index: Int
      let logprobs: String?
      let finish_reason: String
    }

    struct Usage: Codable {
      let prompt_tokens: Int
      let completion_tokens: Int
      let total_tokens: Int
    }
  }

  var text: String
  var callback: (String) -> Void

  @State var isLoading = false

  var body: some View {
    Button { action() } label: {
      Image(systemName: "wand.and.stars")
        .foregroundColor(Color.DS.Background.accent)
        .padding(.grid(1))
    }
    .disabled(isLoading)
    .overlay {
      ActivityIndicator()
        .hidden(isLoading == false)
    }
  }

  private func action() {
    UIImpactFeedbackGenerator(style: .soft).impactOccurred()

    let apiKey = Secrets.openAIKey

    var prompt = """
    Correct any errors in the following transcript, which was generated by Whisper ASR.
    The text may contain incorrect spelling, grammar, or punctuation errors.
    Make sure the corrected text is still coherent and makes sense in context.
    Input can be in any language.
    Output the same language as in input.

    """
    prompt += "Input: \"\(text)\"\n"
    let apiURL = URL(string: "https://api.openai.com/v1/completions")!
    let model = "text-davinci-003"
    let temperature = 0
    let maxTokens = 1000
    let topP: Float = 1
    let frequencyPenalty = 0
    let presencePenalty = 0

    var request = URLRequest(url: apiURL)
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
    request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
    request.httpMethod = "POST"

    let body: [String: Any] = [
      "model": model,
      "prompt": prompt,
      "temperature": temperature,
      "max_tokens": maxTokens,
      "top_p": topP,
      "frequency_penalty": frequencyPenalty,
      "presence_penalty": presencePenalty,
      "stop": "---",
    ]

    Task {
      isLoading = true
      do {
        log(body)

        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        let response = try await URLSession.shared.data(for: request)
        let data = response.0

        log(String(data: data, encoding: .utf8) ?? "no data")

        do {
          let decoder = JSONDecoder()
          let textCompletion = try decoder.decode(TextCompletion.self, from: data)
          if let generatedText = textCompletion.choices.first?.text {
            callback(String(generatedText.trimmingPrefix("\nOutput: ").removingSurrounding("\"")))
          } else {
            log("No choices")
          }
        } catch {
          log(error)

          if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
             let error = json["error"] as? [String: Any],
             let errorMessage = error["message"] as? String {
            log("Error message: \(errorMessage)")
          } else {
            log("Error parsing response")
          }
        }
      } catch {
        log(error)
      }
      isLoading = false
    }
  }
}

extension StringProtocol {
  /// Removes the given delimiter string from both the start and the end of this string if and only if it starts with and ends with the delimiter.
  /// Otherwise returns this string unchanged.
  func removingSurrounding(_ character: Character) -> SubSequence {
    guard count > 1, first == character, last == character else {
      return self[...]
    }
    return dropFirst().dropLast()
  }
}
